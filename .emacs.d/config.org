## -*- coding: utf-8;mode: org;  -*-
* Konfiguracja systemu operacyjnego
- Należy zainstalować czcionkę Iosevka
- Należy zainstalować czcionkę All-the-icons
- Należy ustawić zmienną systemową =ALTERNATE_EDITOR= na =c:\emacs\bin\runemacs.exe=
- Zmienna systemowa =EMACS_SERVER_FILE= na =c:\home\.emacs.d\server\emacs-server-file= (konfiguracja
  nazwy pliku jest dalej w tym pliku. Na chwilę pisania nie jest zależna od komputera <<ale i nie
  synchronizowana pomiędzy nimi>>)
- =HOME= ustawione na =c:\home=
- Dla pythona =WORKON_HOME= ustawione na =c:\home\MojePliki\Python=
- =Total Commander= edytor powinien zostać ustawiony na =C:\emacs\bin\emacsclientw.exe "%1"=
* Podstawowe funkcje menadżera pakietów
** Pakiet =use=
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC
** Pakiet =try=
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** Pakiet =auto-package-update=
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :config
    (setq auto-package-update-interval 14)
    (setq auto-package-update-delete-old-versions t)
    (auto-package-update-maybe)
    )
#+END_SRC
* Podstawowe ustawienia Emacs'a
** Jak działa edycja
Kasowanie znaku klawiszem "DELETE" nie powinno usuwać całego zaznaczenia. I tak używam =C-w= do tego.
#+BEGIN_SRC emacs-lisp
  (setq delete-active-region nil)
  (define-key global-map [C-tab] 'indent-region)
#+END_SRC
** Klawisze windows
#+BEGIN_SRC emacs-lisp
  ;; make PC keyboard's Win key or other to type Super or Hyper, for emacs running on Windows.
  (setq w32-pass-lwindow-to-system nil)
  (setq w32-lwindow-modifier 'super) ; Left Windows key

  (setq w32-pass-rwindow-to-system nil)
  (setq w32-rwindow-modifier 'super) ; Right Windows key

  (setq w32-pass-apps-to-system nil)
  (setq w32-apps-modifier 'hyper) ; Menu/App key
#+END_SRC
** Serwer Emacsa
Uruchom serwer =Emacsa=. Domyślną stroną ma być =*dashboard*=.
=C-x C-c= powinno zamykać ramkę zamiast emacsa?
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (server-force-delete)
(require 'server)
(unless (server-running-p)
  (cond
   ((eq system-type 'windows-nt)
    (setq server-auth-dir "~\\.emacs.d\\server\\"))
   ((eq system-type 'gnu/linux)
    (setq server-auth-dir "~/.emacs.d/server/")))
  (setq server-name "emacs-server-file")
  (server-start))
  (global-set-key (kbd "C-x C-c") 'save-buffers-kill-emacs)
#+END_SRC
** Ustawienia językowe
#+BEGIN_SRC emacs-lisp
  (setq-default buffer-file-coding-system 'utf-8)
  (setq coding-system-for-read 'utf-8)
  (setq coding-system-for-write 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
#+END_SRC
** Wyłączenie kontrolek UI
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC
** Wyłącznie ekranu początkowego
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
** Zamiana pytania =yes/no= na =y/n=
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Auto przeładowywanie zmienionych plików
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode)
#+END_SRC
** Konfiguracja =winner-mode=
 Winner Mode is a global minor mode. 
 When activated, it allows you to /undo/ (and /redo/) changes in the window configuration with the
 key commands =C-c left= and =C-c right=.
 #+BEGIN_SRC emacs-lisp
   (winner-mode 1)
 #+END_SRC
** Konfiguracja =dired=
 Wbudowany eksplorator plików dired. Wywołanie =C-x C-f= i wskazanie katalogu.
*** Używanie =dired= jak Norton Commandera
 #+BEGIN_SRC emacs-lisp
 (setq dired-dwim-target t)
 #+END_SRC
*** =dired+= rozszerza dired
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/dired+")
  (require 'dired+)
#+END_SRC
** Kopie zapasowe plików
Przenosi kopie zapasowe do katalogu =~/.emacs-saves/= i zostawia kilka kopii
#+BEGIN_SRC emacs-lisp
(setq
   backup-by-copying t
   backup-directory-alist
    '(("." . "~/.emacs-saves/"))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)
#+END_SRC
** Funkcja =windmove= 
Pozwala przełączać się pomiędzy oknami za pomocą strzałek połączonych z klawiszem =alt-Window=. 
#+BEGIN_SRC emacs-lisp
;;(windmove-default-keybindings)
(global-set-key (kbd "M-s-<left>")  'windmove-left)
(global-set-key (kbd "M-s-<right>") 'windmove-right)
(global-set-key (kbd "M-s-<up>")    'windmove-up)
(global-set-key (kbd "M-s-<down>")  'windmove-down)
;; Make windmove work in org-mode:
;;(add-hook 'org-shiftup-final-hook 'windmove-up)
;;(add-hook 'org-shiftleft-final-hook 'windmove-left)
;;(add-hook 'org-shiftdown-final-hook 'windmove-down)
;;(add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC
** Wyświetl mi godzinę w modeline
#+BEGIN_SRC emacs-lisp
  (display-time)
#+END_SRC
** Nadpisywanie działania =emacs=
*** W trybie =bat-mode= uruchamiaj batche asynchronicznie
#+BEGIN_SRC emacs-lisp
  (advice-add 'bat-run :override
              (lambda () 
                (interactive)
                (save-buffer)
                (async-shell-command buffer-file-name))
              )
#+END_SRC
* Dodatkowe funkcje
** Kopiowanie całej linii
   Kopiuje całą linię i dodaje ją do =kill-ring=. Podłączone pod
   klawisz =C-c C-k=.
#+BEGIN_SRC emacs-lisp
    (defun copy-line (arg)
        "Copy lines (as many as prefix argument) in the kill ring.
          Ease of use features: - Move to start of next line.  -
          Appends the copy on sequential calls.  - Use newline as
          last char even on the last line of the buffer.  - If region
          is active, copy its lines."
        (interactive "p")
        (let ((beg (line-beginning-position))
              (end (line-end-position arg)))
          (when mark-active
            (if (> (point) (mark))
                (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
              (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
          (if (eq last-command 'copy-line)
              (kill-append (buffer-substring beg end) (< end beg))
            (kill-ring-save beg end)))
        (kill-append "\n" nil)
        (beginning-of-line (or (and arg (1+ arg)) 2))
        (if (and arg (not (= 1 arg))) (message "%d lines copied" arg)))

  (global-set-key "\C-c\C-k" 'copy-line)
#+END_SRC
** Wstawianie linii nad i pod kursorem
Wstawia linię nad =M-p= lub pod =M-n= kursorem nie łamiąc przy tym
linii, i przesuwa kursor do nowej linii.
#+BEGIN_SRC emacs-lisp
  (defun insert-line-below ()
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line))

  (defun insert-line-above ()
    (interactive)
    (move-beginning-of-line nil)
    (newline-and-indent)
    (indent-according-to-mode)
    (previous-line))

  (global-set-key (kbd "M-n") 'insert-line-below)
  (global-set-key (kbd "M-p") 'insert-line-above)

#+END_SRC
** Konfig
*** Otwarcie pliku z konfigiem
 #+BEGIN_SRC emacs-lisp
   (defun config-visit()
     (interactive)
     (find-file "~/.emacs.d/config.org"))
 #+END_SRC
*** Przeładowanie konfigu
#+BEGIN_SRC emacs-lisp
  (defun config-reload()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
** Bardziej normalne przeskok do przodu/tyłu o słowo
#+BEGIN_SRC emacs-lisp
  (defun geosoft-forward-word ()
     ;; Move one word forward. Leave the pointer at start of word
     ;; instead of emacs default end of word. Treat _ as part of word
     (interactive)
     (forward-char 1)
     (backward-word 1)
     (forward-word 2)
     (backward-word 1)
     (backward-char 1)
     (cond ((looking-at "_") (forward-char 1) (geosoft-forward-word))
	   (t (forward-char 1))))

  (defun geosoft-backward-word ()
     ;; Move one word backward. Leave the pointer at start of word
     ;; Treat _ as part of word
     (interactive)
     (backward-word 1)
     (backward-char 1)
     (cond ((looking-at "_") (geosoft-backward-word))
	   (t (forward-char 1))))

  (global-set-key (kbd "M-f") 'geosoft-forward-word)
  (global-set-key (kbd "M-b") 'geosoft-backward-word)
#+END_SRC
** Lepsze dzielenie okien
   Dzielenie okien oraz przesunięcie kursora do nowego okna
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-window-horizontally()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun split-and-follow-window-vertically()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
#+END_SRC
** Lepsze kasowanie całej linii
   kasuje linie i naprawia puste znaki - przydatne z łączeniem do następnej linii
#+BEGIN_SRC emacs-lisp
  (defun radekg-kill-line()
    (interactive)
    (kill-line)
    (fixup-whitespace))
#+END_SRC
** Lepsze łączenie linii
   Funkcja do łączenia linii z następną. Nie przesuwa kursora /KOMENTARZ: może jednak powinna
   przesuwać punkt na koniec linii?/
#+BEGIN_SRC emacs-lisp
  (defun radekg-join-line()
    (interactive)
    (save-excursion
      (join-line 1)
      )
    )
#+END_SRC
** Zawsze usuwaj obecny bufor
#+BEGIN_SRC emacs-lisp
  (defun kill-curr-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+END_SRC
** Wstawianie nieaktywnego timestampu w trybie =org=  
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-.")
                  (lambda()
                    (interactive)
                    (setq current-prefix-arg '(16))
                    (call-interactively 'org-time-stamp-inactive)))
#+END_SRC

* Obejścia problemów
** Problem z wydajnością czcionek
   Odczuwalny bardzo przy korzystaniu z pakietu =org-bullets=
#+BEGIN_SRC emacs-lisp
(setq inhibit-compacting-font-caches 't)
#+END_SRC
* Wygląd
** Motyw
#+BEGIN_SRC emacs-lisp
      ;; (use-package zenburn-theme
      ;;   :ensure t)
  (use-package monokai-theme
    :ensure t
    :init
    (load-theme 'monokai t nil)
    )
  ;; (use-package material-theme
    ;; :ensure t)
#+END_SRC
** Przeźroczystość
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(alpha . (93 . 85)))
  (set-frame-parameter nil 'alpha '(93 . 85))
#+END_SRC
** Czcionka
Źródła czcionki na [[https://github.com/adobe-fonts/source-code-pro][GitHub]]
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
		      :font "Iosevka"
		      :weight 'normal
		      :width 'normal
		      :height 110)
#+END_SRC
** Dodatkowe /upiększenia/
   - Podświetlanie linii
   - Zamiana np. symbolu lambda
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
  (global-prettify-symbols-mode t)
#+END_SRC
** Rozmiary okna
#+BEGIN_SRC emacs-lisp
  (when window-system (set-frame-size (selected-frame) 200 50))
  (add-to-list 'default-frame-alist '(height . 50))
  (add-to-list 'default-frame-alist '(width . 200))
#+END_SRC
** Kolumna przepełnienia (=fill=)
   Kolumna, po której następuje przepełnienie i nowa linia. Całe paragraphy
   można ponownie formatować korzystając z =M-q=.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column '100)
#+END_SRC
** Emoji
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :config (setq emojify-display-style 'image)
            (setq emojify-emoji-set "twemoji-v2-22")
    :init (global-emojify-mode 1)
    :bind ("C-. ." . emojify-insert-emoji)
    :ensure t
    )
#+END_SRC
** Whitespace
Pokazuj spacje w trybie programowym
#+BEGIN_SRC emacs-lisp
  ;; Make whitespace-mode with very basic background coloring for whitespaces.
  ;; http://ergoemacs.org/emacs/whitespace-mode.html
  (setq whitespace-style (quote (face spaces space-mark tabs tab-mark space-after-tab space-before-tab empty trailing)))

  (setq whitespace-display-mappings
        '(
          (space-mark 32 [183] [46])
          (newline-mark 10 [182 10])
          (tab-mark 9 [9655 9] [92 9])
          ))

  (add-hook 'prog-mode-hook 'whitespace-mode)
  (whitespace-mode 1)
  (set-face-attribute 'whitespace-space nil :foreground "gray20")
  (whitespace-mode 0)
#+END_SRC

* Pakiety
** Pakiet =Org=
*** Instalacja
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t)
#+END_SRC
*** Logowanie
#+BEGIN_SRC emacs-lisp
  (setq org-log-into-drawer t)
#+END_SRC
*** Podstawowe ustawienia
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda()
                             (auto-fill-mode 1)
                             (org-indent-mode 1)
                             ))
  (setq org-hide-leading-stars 't)
  (setq org-directory "~/MojePliki/org/")
  (setq org-agenda-skip-unavailable-files t)
  (setq org-agenda-start-on-weekday nil)
  (setq org-tags-column 99)
#+END_SRC
*** Definicja polskich słów kluczowych
    Zostawiamy =TODO= bo to zbyt często używane słowo kluczowy w org.
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t!)" "ROZPOCZĘTE(r)" "|" "ZAKOŃCZONE(z!)" ))
       org-todo-keyword-faces 
       '(
         ("TODO" :foreground "#ff6c85" :weight bold :underline t)
         ("NASTĘPNE" :foreground "#5f5efe" :weight normal :underline t)
         ("ROZPOCZĘTE" :foreground "#0098dd" :weight bold :underline t)
         ("OCZEKUJE" :foreground "#9f7efe" :weight normal :underline t)
         ("WSTRZYMANE" :foreground "#707070" :weight normal :underline t)
         ("KIEDYŚ" :foreground "#80A080" :weight normal :underline t)
         ("ZAKOŃCZONE" :foreground "#60c15f" :weight normal :underline t)
         ("ANULOWANE" :foreground "#40913f" :weight normal :underline t))
)
#+END_SRC
*** Zadania z datą i =TODO= powinny się znaleźć na liście rzeczy do zrobienia
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-todo-ignore-with-date nil)
#+END_SRC
*** Ustawienia kalendarza europejskiego
#+BEGIN_SRC emacs-lisp
  (setq european-calendar-style t)
  (setq calendar-week-start-day 1)
#+END_SRC
*** Pakiet =org-bullets=
#+BEGIN_SRC emacs-lisp
  ;;\22B9 \22C2 ? \u233 ? ? \u2234  ?
     (use-package org-bullets
       :ensure t
       :config
       (setq org-bullets-bullet-list '("\u2836")) ;; eweuntualnie 2894
       (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1))))
#+END_SRC
*** Enter /wchodzi/ w linki
#+BEGIN_SRC emacs-lisp
  (setq org-return-follows-link 't)
#+END_SRC
*** Brak pustych linii przed głównymi punktami
#+BEGIN_SRC emacs-lisp
  ;; (setq org-blank-before-new-entry
  ;;       '((heading . nil) (plain-list-item . nil)))
#+END_SRC
*** Przejście do początku, końca linii ignoruje gwiazdki itp.
#+BEGIN_SRC emacs-lisp
  (setq org-special-ctrl-a/e t)
#+END_SRC
*** Automatyczne zapisywanie wszystkich plików =.org=
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook
	    (lambda ()
	      (run-with-timer 300 300 'org-save-all-org-buffers)))
#+END_SRC
*** Szablony Org-capture
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(
     ;; TODO     (t) Todo template
     ("t" "ToDo" entry (file "refile.org")
      "* TODO %?
    :LOGBOOK:
    - State \"TODO\"       from \"\"           %U
    :END:" :empty-lines 1)
     ("n" "Notatka" entry (file "refile.org")
      "* %? %U" :empty-lines 1)
     ("r" "RPG" entry (file "refile.org")
      "* %? %U :rpg:" :empty-lines 1)
     ("j" "Journal" entry (file+datetree "journal.org")
      "* %? %U" :empty-lines 1)
     )
        )
#+END_SRC
*** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets (quote (("organizator.org" :maxlevel . 3)
                                   )))
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path t)
  (setq org-log-refile 'time)

#+END_SRC

*** Agenda
**** Pliki agendy
  #+BEGIN_SRC emacs-lisp
;;    (setq org-agenda-files (list org-directory) )
(setq org-agenda-files '("organizator.org" "refile.org" "dates.org" "journal.org"))
  #+END_SRC
**** Zadania zaplanowane na przyszłość nie pojawią się na liście =TODO=
 #+BEGIN_SRC emacs-lisp
   (setq org-agenda-todo-ignore-scheduled (quote future))
 #+END_SRC

**** Zadania z =DEADLINE=, które kończą się /niedługo/ znajdą się na liście =TODO=.
 #+BEGIN_SRC emacs-lisp
   (setq org-agenda-todo-ignore-deadlines (quote far))
 #+END_SRC
**** Zadanie =ZROBIONE=, które są zaplanowane nie powinny znaleźć się w agendzie
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-skip-scheduled-if-done t)
#+END_SRC
*** Podpakiet =org-reverse-datetree=
Pozwwala obsługiwać odwrócone drzewo dat
Przydatna komenda =C-@= przeskakuje do liścia z obecnego dnia lub tworzy nowe. Tylko w trybie =org=
#+BEGIN_SRC emacs-lisp
  (use-package org-reverse-datetree
    :ensure t
    :bind
    (:map org-mode-map
          ("C-@" . (lambda()(interactive)(org-reverse-datetree-goto-date-in-file))
          )
          )
    )
#+END_SRC

** Pakiet =ivy=
Zamiast pakietu =helm= - uzupełnianie komend
#+BEGIN_SRC emacs-lisp
  ;; (use-package ivy
  ;;   :ensure t
  ;;   :config
  ;;   (ivy-mode 1)
  ;;   (setq ivy-use-virtual-buffers t)
  ;;   (setq ivy-count-format "(%d/%d) ")
  ;;   )
#+END_SRC
** Pakiet =posframe= i inne
Pokazuje okno zamiast mieszać w statusie
#+BEGIN_SRC emacs-lisp
  (use-package posframe
    :ensure t
    )

  ;; (use-package helm-posframe
  ;;   :ensure t
  ;;   :config
  ;;   (helm-posframe-enable)
  ;;   (setq helm-posframe-parameters
  ;;     '((left-fringe . 10)
  ;;       (right-fringe . 10)))
  ;;   )

  ;; (use-package ivy-posframe
  ;;   :ensure t
  ;;   :config
  ;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display)))
  ;;   (ivy-posframe-mode 1)
  ;;   )

  ;; (use-package company-posframe
  ;;   :ensure t
  ;;   :config
  ;;   (company-posframe-mode 1)
  ;;   )
#+END_SRC
** Pakiet =counsel=
Rozszerza możliwości ivy?
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind (
    ("M-x" . counsel-M-x)
    ("M-y" . counsel-yank-pop)
    ("C-x C-f" . counsel-find-file)
    ("C-h f" . counsel-describe-function)
    ("C-h v" . counsel-describe-variable)
    ("C-h l" . counsel-find-library)
    ("C-h S" . counsel-info-lookup-symbol)
    ("<f2> u" . counsel-unicode-char)
    :map ivy-minibuffer-map
    ("M-y" . ivy-next-line)
    )
  )
#+END_SRC
** Pakiet =Helm=
#+BEGIN_SRC emacs-lisp
    (use-package helm
      :ensure t
      :init (helm-mode 1)
      :config
      (setq helm-boring-buffer-regexp-list (list (rx "*magit-") (rx "*helm")))
      :bind
      ("M-x" . helm-M-x)
      ("C-x C-b" . helm-buffers-list)
      ("C-x C-f" . helm-find-files)
      ("C-x r b" . helm-bookmarks)
  )
#+END_SRC
*** =TAB= powinien uzupełniać wpisy, a nie pokazywać pomoc
#+BEGIN_SRC emacs-lisp
(define-key helm-find-files-map "\t" 'helm-execute-persistent-action)
#+END_SRC
** Pakiet =Which-key=
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+END_SRC
** Pakiet =company=
Podpowiadacz tekstu w Emacs
[[http://company-mode.github.io/][Link do githuba]]
#+BEGIN_SRC emacs-lisp
   (use-package company
     :ensure t
     :diminish (company-mode . " @")
     :hook
     (after-init . global-company-mode)
     :config
     (add-to-list 'company-backends 'company-omnisharp)
     (add-to-list 'company-backends 'company-jedi)
     (setq company-idle-delay 1
           company-require-match nil)
     :bind
     ("M-<SPC>" . company-complete)
     (:map company-active-map
           ("C-n" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort))
     )

  (use-package company-quickhelp
     :ensure t
     :init (with-eval-after-load 'company
             (company-quickhelp-mode)))

#+END_SRC
** Pakiet =Yasnippet=
   Snippety. Uruchamiany przez napisanie w buforze /nazwy/ snippetu i
   naciśnięcie klawisza =TAB=. Nowe snippety można umieszczać w katalogu
   =~/.emacs.d/snippets/<nazwa_trybu>=. Więcej informacji na stronie
   [[http://joaotavora.github.io/yasnippet/snippet-development.html][Jak pisać snippety]].
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t 
    :config
    (yas-global-mode 1))
#+END_SRC
*** Pakiet =Yasnippet Snippets=
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets
    :ensure t
    )
#+END_SRC
*** Integracja z =Company=
#+BEGIN_SRC emacs-lisp
  (defun check-expansion ()
    (save-excursion
      (if (looking-at "\\_>") t
        (backward-char 1)
        (if (looking-at "\\.") t
          (backward-char 1)
          (if (looking-at "->") t nil)))))

  (defun do-yas-expand ()
    (let ((yas/fallback-behavior 'return-nil))
      (yas/expand)))

  (defun tab-indent-or-complete ()
    (interactive)
    (if (minibufferp)
        (minibuffer-complete)
      (if (or (not yas/minor-mode)
              (null (do-yas-expand)))
          (if (check-expansion)
              (company-complete-common)
            (indent-for-tab-command)))))

#+END_SRC
** Pakiet =Beacon=
   Przy przełączaniu okien pomaga znaleźć kursor.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
    )
#+END_SRC
** Pakiet =Ace Window=
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
	 ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      )		  
    )
#+END_SRC
** Pakiet =Swiper=
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    ("C-s" . swiper)
    )
#+END_SRC
** Pakiet =Undo Tree=
   Więcej informacji na [[https://elpa.gnu.org/packages/undo-tree.html][Stronie elpa]]
*** Instalacja
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    (global-undo-tree-mode))
#+END_SRC
*** Skróty klawiszowe
    * =C-_ C-/= (`undo-tree-undo') Undo changes.
    * =M-_ C-?= (`undo-tree-redo') Redo changes.
    * =undo-tree-switch-branch= Switch undo-tree branch.  (What does this mean? Better press the button and see!)
    * =C-x u= (`undo-tree-visualize') Visualize the undo tree.  (Better try pressing this button too!)
    * =C-x r u= (`undo-tree-save-state-to-register') Save current buffer state to register.
    * =C-x r U= (`undo-tree-restore-state-from-register') Restore buffer state from register.
** Pakiet =Powershell=
   Wprowadza tryb do edycji plików =.ps1= czyli =Powershell=. Przynajmniej
   taką mam nadzieję
*** Instalacja
#+BEGIN_SRC emacs-lisp
  (use-package powershell
    :ensure t)
#+END_SRC
** Pakiet =magit=
   Pakiet do obsługi =git= w emacs
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC
Aby prośby o hasło działały pod *Windows* musimy skonfigurować gita by używał GUI do zapytań. Warto
w tym miejscu sprawdzić:
- Konfigurację *Git* do zapamiętywania haseł poleceniem =git config --global credential.helper manager=
- Upewnić się, że windowsowy *ssh-agent* działa/nie jest wyłączony na stałe w usługach windows. :/
  Pod Windows 10 nosi nazwę =OpenSSH Authentication Agent=
- Że klucze *SSH* są dodane do agent poleceniem =ssh-add ~/.ssh/*_rsa= lub podobnym (obserwować
  komunikaty! - uprawnienia!)
- Oraz *Emacs* musi komunikować się przez popupy, więc git musi prosić o hasło do klucza poprzez
  ui. W tym celu należy (najlepiej) ustawić zmienną systemową np. =set SSH_ASKPASS=c:\Program
  Files\Git\mingw64\libexec\git-core\git-askpass.exe=. 

#+BEGIN_SRC emacs-lisp
  (setenv "GIT_ASKPASS" "git-gui--askpass")
#+END_SRC
** Pakiet =avy=
   =M-s= wpisujesz pierwsze litery słowa i przeskakuje lub daje wybór jeśli znalazł więcej
   =M-S= wpisujesz tylko jedną literę. Chyba mniej wygodne.
   =M-l= Daje wybór linii
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-char-timer)
    ("M-l" . avy-goto-line)
    ("M-S" . avy-goto-char))
#+END_SRC
** Pakiet =flycheck=
*** Instalacja
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode t))
#+END_SRC
** Pakiet =highlight-symbol=
   Ekwiwalent vimowego =*= oraz =#= + podświetlanie symbolu
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :init
    (highlight-symbol-mode 1)
    :bind ([C-f3] . highlight-symbol)
    ("C-*" . highlight-symbol-next)
    ("C-#" . highlight-symbol-prev)
    ("C-M-*" . highlight-symbol-query-replace)
    )
#+END_SRC
** Pakiet =dashboard=
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq dasboard-items '((recents . 10)))
    (setq dashboard-center-content t)
    (setq dasboard-banner-logo-title "Cześć!")
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-set-navigator t)
    (setq dashboard-set-init-info t)
    (add-to-list 'dashboard-items '(agenda) t)
    (setq show-week-agenda-p t))
#+END_SRC
** Pakiet =autocomplete=
Dopełnianie tekstu
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-complete
  ;;   :ensure t
  ;;   :init
  ;;   (progn
  ;;     (require 'auto-complete-config)
  ;;     (ac-config-default)
  ;;     (global-auto-complete-mode t)
  ;;     ))
#+END_SRC
** Pakiet =diminish=
Ukrywa minor mode'y w statusie.
[[https://github.com/emacsmirror/diminish][Link do githuba]]
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'helm-mode)
    (diminish 'undo-tree-mode)
    (diminish 'which-key-mode)
    (diminish 'auto-fill-mode)
    )
#+END_SRC
** Pakiet =dmenu=
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind
    ("s-SPC" . 'dmenu))
#+END_SRC
** Pakiet =symon=
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("s-h" . symon-mode))
#+END_SRC
** Pakiet =hungry-delete=
#+BEGIN_SRC emacs-lisp
  ;; (use-package hungry-delete
  ;;   :ensure t
  ;;   :config
  ;;   (global-hungry-delete-mode))
#+END_SRC
** Pakiet =expand-region=
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "C-=") 'er/expand-region))
#+END_SRC
** Pakiet =neotree=
Drzewo katalogów. Włączanie/Wyłączanie za pomocą klawisza =F8=
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    (setq neo-smart-open t)
    :bind
    ([f8] . neotree-toggle))
#+END_SRC
** Pakiet =nyan-mode=
Nyan mode pokazuje pozycję w pliku przy pomocy... Nyan cat'a ;)
#+BEGIN_SRC emacs-lisp
  (use-package nyan-mode
    :ensure t
    :init
    (nyan-mode 1))
#+END_SRC
** Pakiet =ox-hugo=
#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after ox
    )
#+END_SRC
** Pakiet =projectile=
#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :init
      (projectile-mode +1)
      :bind-keymap
      ("H-p" . projectile-command-map)
  )
#+END_SRC
** Pakiet =omnisharp=
#+BEGIN_SRC emacs-lisp
    (use-package omnisharp
      :ensure t
      :init
      (add-hook 'csharp-mode-hook 'omnisharp-mode)
      (add-hook 'csharp-mode-hook 'company-mode)
      (add-hook 'csharp-mode-hook 'flycheck-mode)
      (add-hook 'csharp-mode-hook 'projectile-mode)
      :bind
      ("C-`" . omnisharp-run-code-action-refactoring)
      ([f5] . recompile)
  )
#+END_SRC
** Pakiet =csharpmode=
   Do obsługi strasznego języka =C#=
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t)
#+END_SRC
** Pakiet =spaceline=
Ładny status bar w emacsie
#+BEGIN_SRC emacs-lisp
  ;; (use-package spaceline
  ;;   :ensure t
  ;;   :config
  ;;   (require 'spaceline-config)
  ;;   (setq powerline-default-separator (quote arrow))
  ;;   (spaceline-spacemacs-theme))
#+END_SRC
** Pakiet =multiple-cursors=
https://github.com/magnars/multiple-cursors.el
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind
    ("C->" . mc/mark-next-like-this-word)
    ("C-<" . mc/mark-previous-like-this-word)
    ("C-c C-<" . mc/mark-all-words-like-this)
    ("C-S-c C-S-c" . mc/edit-lines)
    ("C-S-<mouse-1>" . mc/add-cursor-on-click)
  )
#+END_SRC
** Pakiet =rainbow-delimeters=
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  )
#+END_SRC

** Eksperymenty z =doomline=
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)
  (use-package minions
    :ensure t
    :config (minions-mode 1))

  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config
    (setq doom-modeline-major-mode-color-icon t)

    ;; How wide the mode-line bar should be. It's only respected in GUI.
    (setq doom-modeline-bar-width 10)
    ;; Whether display the icon for the buffer state. It respects `doom-modeline-icon'.
    (setq doom-modeline-buffer-state-icon t)
    ;; Determines the style used by `doom-modeline-buffer-file-name'.
    ;;
    ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
    ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
    ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
    ;;   truncate-with-project => emacs/l/comint.el
    ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
    ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
    ;;   truncate-all => ~/P/F/e/l/comint.el
    ;;   relative-from-project => emacs/lisp/comint.el
    ;;   relative-to-project => lisp/comint.el
    ;;   file-name => comint.el
    ;;   buffer-name => comint.el<2> (uniquify buffer name)
    ;;
    ;; If you are expereicing the laggy issue, especially while editing remote files
    ;; with tramp, please try `file-name' style.
    ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
    (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)

    ;; Whether display the modification icon for the buffer.
    ;; It respects `doom-modeline-icon' and `doom-modeline-buffer-state-icon'.
    (setq doom-modeline-buffer-modification-icon t)

    ;; Whether ;TODO: o use unicode as a fallback (instead of ASCII) when not using icons.
    (setq doom-modeline-unicode-fallback t)

    ;; Whether display minor modes in mode-line.
    (setq doom-modeline-minor-modes (featurep 'minions))
    ;; Whether display buffer encoding.
    (setq doom-modeline-buffer-encoding t)


    ;; The maximum displayed length of the branch name of version control.
    (setq doom-modeline-vcs-max-length 12)

    ;; Whether display environment version.
    (setq doom-modeline-env-version t)

    (setq doom-modeline-vcs-max-length 50)
    )
#+END_SRC
** Pakiet =flymake=
#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :ensure t)
#+END_SRC
** Pakiet =iedit=
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t)
#+END_SRC

* Programowanie
** Numerowanie linii - od Emacs 26
W trybach programistycznych numeruje linie.
#+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC
* Python
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook (lambda () (setq auto-fill-function 'do-auto-fill) (setq fill-column 79)))
  (add-hook 'python-mode-hook (lambda () (hs-minor-mode 1)))
  (bind-keys :map prog-mode-map
             ("<C-S-tab>" . hs-toggle-hiding))
#+END_SRC
** Pakiet =jedi=
   Pakiet uzupełniający dla =Python=.
#+BEGIN_SRC emacs-lisp
  (use-package jedi
    :ensure t
    :init
    (add-hook 'python-mode-hook 'jedi:setup)
    (add-hook 'python-mode-hook 'jedi:ac-setup))

  (use-package company-jedi
    :ensure t)
#+END_SRC
** Pakiet =elpy=
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :config
    (setq python-indent-offset 4)
    (elpy-enable))
#+END_SRC
** WYŁĄCZONY Pakiet =pyvenv=
#+BEGIN_SRC emacs-lisp
  ;; (use-package pyvenv
    ;; :ensure t
    ;; :init
    ;; (pyvenv-mode 1)
    ;; (pyvenv-tracking-mode 1))
#+END_SRC
** Formatowanie i lint dla =python=
#+BEGIN_SRC emacs-lisp
  (use-package py-autopep8
    :ensure t
    :config
    (add-hook 'elpy-mode-hook #'py-autopep8-enable-on-save))

  (use-package blacken
    :ensure t)
#+END_SRC
** Konfiguracja =flymake= dla python
#+BEGIN_SRC emacs-lisp
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC
* Mapowanie klawiszy
  - =C-c c e= - otwórz config
  - =C-c c r= - przeładuj config
  - =C-c c o= - otwórz organizer
  - =C-c c w= - otwórz plik refile
  - =C-c c j= - otwórz journal
  - =C-M-S-k= - kopiuje do =killring= całą linię
  - =C-S-r= - przywraca plik
  - =C-M-k= - łączy linię z następną
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-k") 'kill-whole-line)
  (global-set-key (kbd "C-M-S-k") 'copy-line)
  (global-set-key (kbd "C-c c e") 'config-visit)
  (global-set-key (kbd "C-c c r") 'config-reload)
  (global-set-key (kbd "C-c c o") '(lambda()(interactive)(find-file "~/MojePliki/org/organizator.org")))
  (global-set-key (kbd "C-c c w") '(lambda()(interactive)(find-file "~/MojePliki/org/refile.org")))
  (global-set-key (kbd "C-c c j") '(lambda()(interactive)(find-file "~/MojePliki/org/journal.org")))
  (global-set-key (kbd "C-S-r") 'revert-buffer)
  (global-set-key [remap split-window-below] 'split-and-follow-window-horizontally)
  (global-set-key [remap split-window-right] 'split-and-follow-window-vertically)
  (global-set-key [remap kill-line] 'radekg-kill-line)
  (global-set-key (kbd "C-M-k") 'radekg-join-line) 
  (global-set-key [remap kill-buffer] 'kill-curr-buffer)
  (global-set-key (kbd "C-. >") '(lambda()(interactive)(insert "➡")))
  (global-set-key (kbd "C-. <") '(lambda()(interactive)(insert "⬅")))
 #+END_SRC 
*** Tryb org
**** Mapowanie klawiszy (lokalne)
     Jeśli przejdziemy do źródła linku, skrót =C-M-b= pozwoli wrócić do
     oryginalnej pozycji.
 #+BEGIN_SRC emacs-lisp
   (define-key org-mode-map (kbd "C-M-b") 'org-mark-ring-goto)
 #+END_SRC
**** Mapowanie klawiszy (globalne)
     Globalne ustawienia klawiszy dla =org=.
     - =C-c l= dodaje nowy link
     - =C-c a= otwiera agendę
     - =F6= pozwala dodać do =org-capture=
 #+BEGIN_SRC emacs-lisp
   (global-set-key "\C-cl" 'org-store-link)
   (global-set-key "\C-ca" 'org-agenda)
   (global-set-key (kbd "<f6>") 'org-capture)
 #+END_SRC
* Modeline
Proste metody (formatowanie do bani), które pobierają z windows informacje o pamięci oraz obciążeniu
procesora. Co ciekawe trwa to dość długo. Zupeł nie używalne pod =Windows=. Spróbuję z wersją =Linuksową=.

#+BEGIN_SRC emacs-lisp
  (defun get-free-memory ()
      (format "%0.2f"
	      (/
	       (string-to-number
		(shell-command-to-string "wmic OS get FreePhysicalMemory /Value | grep Free | cut -d '=' -f 2"))
	       1024.0
	       )
	      )
      )

  (defun get-cpu-load ()
    (shell-command-to-string "wmic cpu get loadpercentage /Value | grep Load | cut -d '=' -f 2 | tr -d '[:cntrl:]' ")
    )

  (defun update-mode-line ()
    (setq global-mode-string (concat "Avail: " (get-free-memory) "MB" " CPU: " (get-cpu-load) "%%"))
    )
#+END_SRC

Następnie wkładamy to do =modeline'a= co 10 sekund(?)
#+BEGIN_SRC emacs-lisp
;; nie używalne
;;    (run-at-time "10 sec" 10 'update-mode-line)
#+END_SRC



* Skrypty do pracy
** Budowanie Unita
#+BEGIN_SRC emacs-lisp
  (defun unit/build ()
    "Buduje i uruchamia unit-a"
    (interactive)
    (async-shell-command
     ;; command and parameters
     "c:/work/unit.git/Lib/nant/bin/NAnt.exe -buildfile:c:/work/unit.git/Script/lodz.build build_server_sln build_client deploy_server deploy_client"
     ;; output buffer
     "*Unit-build*"
     ;; name of the error buffer
     nil
     )
    )

  (global-set-key [f9] 'unit/build)
#+END_SRC
